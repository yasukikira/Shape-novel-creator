<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Novel Creator</title>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@300;400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #1a1a1a;
            --text-color-darker: #000000; 
            --border-color: #1a1a1a;
            --accent-color: #4a4a4a;
            --danger-color: #D8000C;
            --danger-bg-color: #ffdddd;
            --font-main: 'Roboto', sans-serif;
            --font-manga: 'Kalam', cursive;
            --imperfect-border-radius: 3px 5px 2px 4px / 4px 3px 5px 2px;
            --imperfect-shadow: 2px 2px 0px 0px var(--border-color);
            --imperfect-shadow-hover: 3px 3px 0px 0px var(--border-color), 1px 1px 0px 1px var(--border-color);
            --inset-shadow: inset 1px 1px 2px 0px rgba(0,0,0,0.1);
        }

        body.theme-sepia { 
            --bg-color: #f5e8d0; --text-color: #5c4033; --text-color-darker: #402c22; 
            --border-color: #704214; --accent-color: #8a5a44;
            --inset-shadow: inset 1px 1px 2px 0px rgba(80,50,30,0.15);
        }
        body.theme-galaxy { 
            --bg-color: #0f0c29; --text-color: #e0e0e0; --text-color-darker: #ffffff;
            --border-color: #535069; --accent-color: #c8c8ff;
            --inset-shadow: inset 1px 1px 2px 0px rgba(200,200,255,0.1);
        }
        body.theme-miku { 
            --bg-color: #ffdff7; --text-color: #005f69; --text-color-darker: #004249;
            --border-color: #ff7bac; --accent-color: #39c5bb;
            --inset-shadow: inset 1px 1px 2px 0px rgba(0,50,60,0.1);
        }
        
        body.theme-sepia header, body.theme-sepia .manga-card, body.theme-sepia .manga-detail-header,
        body.theme-sepia .chapter-content .panel-description, body.theme-sepia .chapter-content .last-panel-image-container,
        body.theme-sepia .form-group input, body.theme-sepia .form-group textarea, body.theme-sepia .form-group select,
        body.theme-sepia .tool-output, body.theme-sepia .character-list,
        body.theme-galaxy header, body.theme-galaxy .manga-card, body.theme-galaxy .manga-detail-header,
        body.theme-galaxy .chapter-content .panel-description, body.theme-galaxy .chapter-content .last-panel-image-container,
        body.theme-galaxy .form-group input, body.theme-galaxy .form-group textarea, body.theme-galaxy .form-group select,
        body.theme-galaxy .tool-output, body.theme-galaxy .character-list,
        body.theme-miku header, body.theme-miku .manga-card, body.theme-miku .manga-detail-header,
        body.theme-miku .chapter-content .panel-description, body.theme-miku .chapter-content .last-panel-image-container,
        body.theme-miku .form-group input, body.theme-miku .form-group textarea, body.theme-miku .form-group select,
        body.theme-miku .tool-output, body.theme-miku .character-list {
            background-color: var(--bg-color); color: var(--text-color); border-color: var(--border-color) !important;
        }
        body.theme-sepia button, body.theme-sepia .button,
        body.theme-galaxy button, body.theme-galaxy .button,
        body.theme-miku button, body.theme-miku .button {
            background-color: var(--text-color); color: var(--bg-color); border-color: var(--border-color);
        }
        body.theme-sepia button:hover, body.theme-sepia .button:hover,
        body.theme-galaxy button:hover, body.theme-galaxy .button:hover,
        body.theme-miku button:hover, body.theme-miku .button:hover {
            background-color: var(--accent-color); color: var(--bg-color);
        }
        body.theme-sepia header nav a:hover, body.theme-sepia header nav a.active,
        body.theme-galaxy header nav a:hover, body.theme-galaxy header nav a.active,
        body.theme-miku header nav a:hover, body.theme-miku header nav a.active {
            color: var(--bg-color); background-color: var(--text-color);
        }
        body.theme-sepia .manga-card .cover-image .title-on-cover { background-color: rgba(245, 232, 208, 0.8); color: var(--text-color); border-top-color: var(--border-color); }
        body.theme-galaxy .manga-card .cover-image .title-on-cover { background-color: rgba(15, 12, 41, 0.7); color: var(--text-color); border-top-color: var(--border-color); }
        body.theme-miku .manga-card .cover-image .title-on-cover { background-color: rgba(255, 223, 247, 0.8); color: var(--text-color); border-top-color: var(--border-color); }


        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; padding-top: 80px; transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1000px; margin: 0 auto; padding: 20px; }

        .icon { width: 1em; height: 1em; vertical-align: -0.125em; fill: currentColor; display: inline-block; }
        header nav a .icon { width: 1.2em; height: 1.2em; margin-right: 5px; }
        button .icon { margin-right: 7px; }
        .edit-btn .icon { width: 1em; height: 1em; margin-right: 0; }


        header { background-color: var(--bg-color); border-bottom: 2px solid var(--border-color); box-shadow: var(--imperfect-shadow); padding: 10px 15px; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; display: flex; justify-content: space-between; align-items: center; }
        header .logo { font-family: var(--font-manga); font-size: 1.5em; font-weight: 700; color: var(--text-color); text-decoration: none; line-height: 1.1; text-align: center; text-shadow: 0.3px 0.3px 0px var(--text-color-darker); }
        header nav ul { list-style: none; display: flex; gap: 10px; align-items: center; }
        header nav a { text-decoration: none; color: var(--text-color); font-weight: bold; font-size: 0.9em; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: var(--imperfect-border-radius); transition: all 0.2s ease-in-out; white-space: nowrap; display: inline-flex; align-items: center; gap: 5px; }
        header nav a:hover, header nav a.active { color: var(--bg-color); background-color: var(--text-color); box-shadow: var(--imperfect-shadow-hover); transform: translateY(-1px) translateX(-1px); }
        header nav a .nav-text { display: inline; } 


        .view { display: none; animation: fadeIn 0.5s ease-in-out; }
        .view.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        h1, h2, h3 { font-family: var(--font-manga); margin-bottom: 15px; color: var(--text-color); text-shadow: 0.2px 0.2px 0px var(--text-color-darker); }
        h1 { font-size: 2.2em; text-align: center; margin-bottom: 25px;}
        h2 { font-size: 1.8em; border-bottom: 2px dashed var(--border-color); padding-bottom: 5px;}
        h3 { font-size: 1.4em; }
        #chapterTitleContainer { display: flex; align-items: center; justify-content: center; }
        #chapterTitleContainer .edit-btn { margin-left: 15px; }


        .manga-library-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; }
        .manga-card { border: 2px solid var(--border-color); border-radius: var(--imperfect-border-radius); padding: 10px; background-color: var(--bg-color); box-shadow: var(--imperfect-shadow); text-align: center; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; display: flex; flex-direction: column; }
        .manga-card:hover { transform: translateY(-4px) translateX(-2px) rotate(-1deg); box-shadow: var(--imperfect-shadow-hover); }
        .manga-card .cover-image { width: 100%; height: 220px; background-color: #e0e0e0; border: 1px solid var(--border-color); border-radius: 3px; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; font-family: var(--font-manga); color: var(--text-color); font-size: 1.1em; padding: 0; overflow: hidden; position: relative; }
        .manga-card .cover-image img { width: 100%; height: 100%; object-fit: cover; }
        .manga-card .cover-image .placeholder-text { padding: 10px; font-size: 0.8em; display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: var(--accent-color); }
        .manga-card .cover-image .title-on-cover { position: absolute; bottom: 0; left: 0; width: 100%; background-color: rgba(255,255,255,0.9); color: var(--text-color); padding: 5px; font-size: 0.8em; border-top: 1px solid var(--border-color); border-radius: 0 0 2px 2px; text-align: center; box-sizing: border-box; font-family: var(--font-manga); font-weight: bold; word-wrap: break-word; }

        .image-container { display: flex; align-items: center; justify-content: center; overflow: hidden; border: 1px solid var(--border-color); background-color: #f0f0f0; position:relative; }
        .image-container img { width: 100%; height: 100%; object-fit: cover; }
        .image-container .placeholder-text { font-family: var(--font-manga); color: var(--accent-color); font-size: 0.9em; text-align: center; padding: 10px; }
        .image-container .regen-btn { position: absolute; top: 5px; right: 5px; background-color: rgba(0,0,0,0.5); color: white; border: none; padding: 3px 6px; font-size: 0.7em; cursor: pointer; border-radius: var(--imperfect-border-radius); opacity: 0.7; transition: opacity 0.2s; }
        .image-container:hover .regen-btn { opacity: 1; }

        .manga-detail-header { text-align: center; margin-bottom: 30px; padding: 15px; border: 2px dashed var(--border-color); border-radius: var(--imperfect-border-radius); box-shadow: var(--imperfect-shadow), 0 0 0 2px var(--bg-color), 0 0 0 4px var(--border-color); }
        .manga-detail-header .banner-image { width: 100%; height: 180px; margin-bottom: 15px; border-radius: 3px; }
        .manga-detail-header .manga-icon { width: 90px; height: 90px; border-radius: 50% 45% 55% 50% / 45% 50% 50% 55%; margin: -50px auto 10px auto; border: 3px solid var(--bg-color); box-shadow: var(--imperfect-shadow); position: relative; }
        .manga-detail-header .manga-icon .placeholder-text { font-size: 0.7em; }
        .manga-detail-header .author, .manga-detail-header .description-container { font-size: 0.9em; color: var(--accent-color); margin-bottom: 5px; }
        .manga-detail-header .description-container { font-family: var(--font-main); } 
        .manga-actions { margin-top: 20px; padding-top: 15px; border-top: 1px dashed var(--border-color); display: flex; flex-wrap: wrap; justify-content: space-around; gap: 10px; align-items: center; }
        .edit-btn { font-size: 1em !important; padding: 3px !important; margin-left: 10px; vertical-align: middle; background: none; border: none; box-shadow: none; color: var(--accent-color); cursor:pointer; line-height: 1; }
        .edit-btn:hover { background-color: transparent !important; color: var(--text-color) !important; transform: scale(1.1); }
        .edit-btn .icon { width: 0.8em; height: 0.8em; }


        .chapters-list ul { list-style: none; }
        .chapters-list li a { display: block; padding: 10px 15px; margin-bottom: 8px; border: 1px solid var(--border-color); border-radius: var(--imperfect-border-radius); text-decoration: none; color: var(--text-color); transition: all 0.2s ease; box-shadow: var(--imperfect-shadow); }
        .chapters-list li a:hover { background-color: #f0f0f0; box-shadow: var(--imperfect-shadow-hover); transform: translateX(3px) rotate(-0.5deg); }

        .chapter-content .panel-description { padding: 15px; border: 1px dashed var(--border-color); margin-bottom: 20px; border-radius: var(--imperfect-border-radius); background-color: #fdfdfd;}
        .chapter-content .panel-description p { margin-bottom: 0.5em; font-family: var(--font-main); }
        .chapter-content .last-panel-image-container { text-align: center; margin-top: 30px; padding: 10px; border: 2px solid var(--border-color); border-radius: var(--imperfect-border-radius); }
        .chapter-content .last-panel-image-container .placeholder-text { font-size: 0.9em; margin: 10px; }
        .chapter-content .last-panel-image-container img { max-width: 100%; height: auto; display: block; margin: 10px auto; border: 2px solid var(--border-color); box-shadow: var(--imperfect-shadow); border-radius: 3px; background-color: #eee; }
        .chapter-actions { margin-top: 15px; text-align: center; }


        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; font-family: var(--font-manga); }
        .form-group input[type="text"], .form-group input[type="password"], .form-group textarea, .form-group input[type="file"], .form-group select { width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: var(--imperfect-border-radius); font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); box-shadow: var(--inset-shadow); }
        .form-group input[type="file"] { padding: 5px; }
        .form-group textarea { min-height: 100px; resize: vertical; }
        .tool-output, .character-list { margin-top:15px; padding:10px; border:1px dashed var(--border-color); background-color: #f9f9f9; white-space: pre-wrap; font-family: var(--font-main); max-height: 300px; overflow-y: auto;}
        body.theme-sepia .tool-output, body.theme-sepia .character-list { background-color: #efe2cd; }
        body.theme-galaxy .tool-output, body.theme-galaxy .character-list { background-color: #1f1a3f; color: #d0d0ee; }
        body.theme-miku .tool-output, body.theme-miku .character-list { background-color: #ffeefc; color: #004f59; }
        .character-entry { border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }
        .character-entry:last-child { border-bottom: none; }
        .character-entry h4 { margin-bottom: 5px; font-family: var(--font-manga); }


        button, .button { background-color: var(--text-color); color: var(--bg-color); border: 2px solid var(--border-color); padding: 10px 20px; font-family: var(--font-manga); font-size: 1.1em; cursor: pointer; border-radius: var(--imperfect-border-radius); box-shadow: var(--imperfect-shadow); text-decoration: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s ease; }
        button:hover, .button:hover { background-color: var(--accent-color); color: var(--bg-color); border-color: var(--text-color); box-shadow: var(--imperfect-shadow-hover); transform: translateY(-2px) translateX(-1px) rotate(1deg); }
        button:disabled { background-color: #ccc; color: #777; cursor: not-allowed; box-shadow: none; transform: none; }
        button.danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        button.danger:hover { background-color: #a80000; border-color: #a80000; }

        .text-center { text-align: center; } .mt-20 { margin-top: 20px; } .mb-20 { margin-bottom: 20px; }
        .status-message { padding: 10px; margin-top: 15px; border-radius: var(--imperfect-border-radius); font-family: var(--font-manga); }
        .status-message.error { background-color: var(--danger-bg-color); border: 1px solid var(--danger-color); color: var(--danger-color); }
        .status-message.success { background-color: #ddffdd; border: 1px solid #aaffaa; color: #4F8A10; }
        .status-message.info { background-color: #ddeeff; border: 1px solid #aaccff; color: #00529B; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--accent-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        @media (max-width: 768px) { body { padding-top: 130px; } header { flex-direction: column; align-items: flex-start; } header .logo { margin-bottom: 10px;} header nav ul { flex-wrap: wrap; gap: 5px; justify-content: flex-start; } header nav a { font-size: 0.8em; padding: 5px 8px; } h1 { font-size: 1.8em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; } .manga-library-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; } .manga-card .cover-image { height: 200px; } .manga-actions { flex-direction: column; gap: 10px; } }
    </style>
</head>
<body id="appBody">
    <header>
        <a href="#library" class="logo">Shapes<br>Novel</a>
        <nav>
            <ul>
                <li><a href="#library" id="nav-library">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                    <span class="nav-text">Library</span></a></li>
                <li><a href="#create" id="nav-create">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    <span class="nav-text">Create</span></a></li>
                <li><a href="#character-tool" id="nav-character-tool">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                    <span class="nav-text">Characters</span></a></li>
                <li><a href="#plot-tool" id="nav-plot-tool">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>
                    <span class="nav-text">Plot</span></a></li>
                <li><a href="#settings" id="nav-settings">
                    <svg class="icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M10.83 5a3.001 3.001 0 0 0-5.66 0H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17ZM4 11h9.17a3.001 3.001 0 0 1 5.66 0H20a1 1 0 1 1 0 2h-1.17a3.001 3.001 0 0 1-5.66 0H4a1 1 0 1 1 0-2Zm1.17 6H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17a3.001 3.001 0 0 0-5.66 0Z"/>
                    </svg>
                    <span class="nav-text">Settings</span></a>
                </li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <div id="view-library" class="view"> <h1>My Novel Library</h1> <div class="form-group"> <label for="importFile" class="button" style="display:inline-block; margin-bottom: 20px;"> <svg class="icon" viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></svg> Import</label> <input type="file" id="importFile" accept=".json" style="display: none;"> <div id="importStatus" class="status-message" style="display:none;"></div> </div> <div id="mangaLibraryGrid" class="manga-library-grid"></div> <p id="noMangaMessage" class="text-center mt-20" style="display:none;">No novel created yet. <a href="#create" class="button-link">Create one!</a></p> </div>
        <div id="view-create" class="view"> <h1>Create New Novel</h1> <form id="createMangaForm"> <div class="form-group"> <label for="mangaIdea">Your Novel Idea (brief description):</label> <textarea id="mangaIdea" rows="4" required placeholder="e.g., A fantasy epic about a cursed knight seeking redemption."></textarea> </div> <button type="submit" id="startMangaCreationBtn">Start Creating!</button> <div id="creationLoading" class="loading-spinner" style="display:none;"></div> <div id="creationStatus" class="status-message" style="display:none;"></div> </form> </div>
        <div id="view-manga-detail" class="view"> <div id="mangaDetailContent"></div> <div class="form-group mt-20"> <label for="mangaSpecificArtStylePreset">Art Style for This Manga:</label> <select id="mangaSpecificArtStylePreset"></select> <button id="saveMangaArtStyleBtn" class="edit-btn" style="margin-left: 0; margin-top: 5px;"> <svg class="icon" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg> Save Style</button> </div> <div class="manga-actions"> <button id="exportMangaBtn" style="display:none;"> <svg class="icon" viewBox="0 0 24 24"><path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" /></svg> Export Full Manga</button> <button id="continueStoryBtn" style="display:none;">Continue Story</button> <button id="deleteMangaBtn" class="danger" style="display:none;"> <svg class="icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"> <path fill-rule="evenodd" d="M8.586 2.586A2 2 0 0 1 10 2h4a2 2 0 0 1 2 2v2h3a1 1 0 1 1 0 2v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V8a1 1 0 0 1 0-2h3V4a2 2 0 0 1 .586-1.414ZM10 6h4V4h-4v2Zm1 4a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Zm4 0a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Z" clip-rule="evenodd"/> </svg> Delete Manga</button> </div> <div id="mangaDetailStatus" class="status-message mt-20" style="display:none;"></div> <div id="chapterCreationLoading" class="loading-spinner" style="display:none;"></div> </div>
        <div id="view-chapter" class="view"> <h1 id="chapterTitleContainer"> <span id="chapterTitleText">Chapter Title</span> <button class="edit-btn" id="editChapterTitleBtn" title="Edit Chapter Title"><svg class="icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"> <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14.304 4.844 2.852 2.852M7 7H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-4.5m2.409-9.91a2.017 2.017 0 0 1 0 2.853l-6.844 6.844L8 14l.713-3.565 6.844-6.844a2.015 2.015 0 0 1 2.852 0Z"/> </svg></button> </h1> <div id="chapterContent" class="chapter-content"></div> <div class="chapter-actions"> <button id="exportChapterBtn" style="display:none;"> <svg class="icon" viewBox="0 0 24 24"><path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" /></svg> Export Chapter</button> </div> <div class="text-center mt-20"> <a href="#" id="backToMangaDetail" class="button">Back to Manga Info</a> </div> </div>
        <div id="view-character-tool" class="view"> <h1>Character Tool</h1> <div class="form-group"> <label for="charToolMangaSelect">Select Novel:</label> <select id="charToolMangaSelect"></select> </div> <hr> <h3>Existing Characters</h3> <div id="existingCharactersList" class="character-list" style="margin-bottom: 20px;">Select a manga.</div> <hr> <h3>Add/Define New Character</h3> <form id="characterToolForm"> <div class="form-group"> <label for="charToolName">Name:</label> <input type="text" id="charToolName" required> </div> <div class="form-group"> <label for="charToolAppearance">Appearance:</label> <textarea id="charToolAppearance" rows="2"></textarea> </div> <div class="form-group"> <label for="charToolPersonality">Personality/Quirks:</label> <textarea id="charToolPersonality" rows="2"></textarea> </div> <button type="submit" id="addCharacterBtn"> <svg class="icon" viewBox="0 0 24 24"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg> Add Character</button> <button type="button" id="askShapeForCharacterBtn"> <svg class="icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4M12,10C14.21,10 16,11.79 16,14V16H8V14C8,11.79 9.79,10 12,10Z" /></svg> Ask Shape for Ideas</button> </form> <div id="charToolLoading" class="loading-spinner" style="display:none;"></div> <div id="charToolOutput" class="tool-output" style="display:none;"></div> </div>
        <div id="view-plot-tool" class="view"> <h1>Plot Notes Tool</h1> <div class="form-group"> <label for="plotToolMangaSelect">Select Novel:</label> <select id="plotToolMangaSelect"></select> </div> <form id="plotToolForm"> <div class="form-group"> <label for="plotToolMainPlot">Main Plot / Story Goal:</label> <textarea id="plotToolMainPlot" rows="4" placeholder="What is the overall objective or direction?"></textarea> </div> <div class="form-group"> <label for="plotToolTwists">Upcoming Plot Twists / Key Events:</label> <textarea id="plotToolTwists" rows="3" placeholder="Ideas for future chapters..."></textarea> </div> <button type="submit" id="savePlotNotesBtn"> <svg class="icon" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg> Save Notes</button> <button type="button" id="askShapeForPlotBtn"> <svg class="icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,15H13V17H11V15M11,7H13V13H11V7Z" /></svg> Ask Shape for Ideas</button> </form> <div id="plotToolLoading" class="loading-spinner" style="display:none;"></div> <div id="plotToolOutput" class="tool-output" style="display:none;"></div> </div>
        <div id="view-settings" class="view"> <h1>Settings</h1> <form id="settingsApiForm"> <div class="form-group"> <label for="apiKey">Shapes API Key:</label> <input type="password" id="apiKey" required> </div> <div class="form-group"> <label for="shapeVanityUrl">Shape Vanity URL (e.g., shapesinc/your_shape_username):</label> <input type="text" id="shapeVanityUrl" placeholder="shapesinc/example_shape" required> </div> <button type="button" id="saveApiSettingsBtn">Save API Settings</button> <div id="settingsStatus" class="status-message" style="display:none;"></div> <p id="shapeInfo" class="mt-20" style="font-style: italic;"></p> </form> <hr style="margin: 30px 0; border-top: 1px dashed var(--border-color);"> <form id="settingsDisplayForm"> <h2>Visual Theme</h2> <div class="form-group"> <label for="themeSelector">Select Theme:</label> <select id="themeSelector"> <option value="default">Manga B&W</option> <option value="sepia">Sepia Tone</option> <option value="galaxy">Galaxy Dark</option> <option value="miku">Miku Wave</option> </select> </div> <h2>Art Style Presets</h2> <div class="form-group"> <label for="artStylePresetGlobal">Global Art Style (Default):</label> <select id="artStylePresetGlobal"> </select> </div> <div class="form-group"> <label for="customArtStylePreset">Your Custom Preset Keywords (comma-separated):</label> <input type="text" id="customArtStylePreset" placeholder="e.g., surreal, vaporwave aesthetic, vibrant colors"> <p style="font-size:0.8em; color: var(--accent-color);">This will be an option in the preset dropdowns.</p> </div> <button type="button" id="saveDisplaySettingsBtn">Save Display Settings</button> <div id="displaySettingsStatus" class="status-message" style="display:none;"></div> </form> </div>
    </div>

    <script>
        // JavaScript is largely the same as the previous version with the fixes.
        // Key points:
        // - All event listeners should be correctly attached, especially for dynamic elements.
        // - `_toCamelCase` and its usage in router/nav active state is crucial.
        // - `populateMangaSelectsForTools` should correctly trigger a 'change' event if a default is set.
        // - `_renderImageIntoContainer` already handles regen button display if callback is provided.
        // - Prompts in handleCreateNewManga and handleContinueStory already use the artStylePreset logic.

        const App = { /* ... (config, data, currentMangaId, etc. same as before) ... */
            config: { apiKey: '', shapeVanityUrl: '', shapeUsername: '', shapeDisplayName: '', userId: '', theme: 'default', artStylePresetGlobal: '', customArtStylePreset: '' },
            data: { mangas: [] }, currentMangaId: null, currentChapterIndex: null, views: {}, navLinks: {},
            
            artStylePresets: { "none": "None (Shape's Default)", "manga_standard": "Standard Manga (B&W, Hand-drawn)", "manhwa_color": "Manhwa Style (Full Color, Detailed)", "shonen_classic": "Classic Shonen (Dynamic, Clean B&W)", "dark_fantasy_sketch": "Dark Fantasy Sketch (Gritty, Inked B&W)", "chibi_cute": "Chibi/Cute (Simple, Rounded B&W)", "seinen_detailed": "Detailed Seinen (Fine Lines, Monochrome)" },

            init() { /* ... same ... */
                this.views = { library: document.getElementById('view-library'), create: document.getElementById('view-create'), mangaDetail: document.getElementById('view-manga-detail'), chapter: document.getElementById('view-chapter'), characterTool: document.getElementById('view-character-tool'), plotTool: document.getElementById('view-plot-tool'), settings: document.getElementById('view-settings') };
                this.navLinks = { library: document.getElementById('nav-library'), create: document.getElementById('nav-create'), characterTool: document.getElementById('nav-character-tool'), plotTool: document.getElementById('nav-plot-tool'), settings: document.getElementById('nav-settings') };
                this.loadConfig(); this.applyTheme(); this.populateArtStyleDropdowns(); this.loadMangas(); this.generateUserId(); this.setupEventListeners(); this.router(); window.addEventListener('hashchange', () => this.router());
            },
            populateArtStyleDropdowns() { /* ... same ... */ const globalSelect = document.getElementById('artStylePresetGlobal'); const mangaSpecificSelect = document.getElementById('mangaSpecificArtStylePreset'); const selects = [globalSelect, mangaSpecificSelect].filter(Boolean); selects.forEach(select => { select.innerHTML = ''; if (select === mangaSpecificSelect) { const optGlobal = document.createElement('option'); optGlobal.value = ""; optGlobal.textContent = "Use Global Setting"; select.appendChild(optGlobal); } for (const key in this.artStylePresets) { const option = document.createElement('option'); option.value = key === "none" ? "" : this.artStylePresets[key]; option.textContent = this.artStylePresets[key]; select.appendChild(option); } if (this.config.customArtStylePreset && this.config.customArtStylePreset.trim() !== "") { const customOption = document.createElement('option'); customOption.value = this.config.customArtStylePreset; customOption.textContent = `Custom: ${this.config.customArtStylePreset.substring(0,30)}${this.config.customArtStylePreset.length > 30 ? '...' : ''}`; select.appendChild(customOption); } }); },
            applyTheme() { document.body.className = this.config.theme !== 'default' ? `theme-${this.config.theme}` : ''; },
            generateUserId() { /* ... same ... */ let userId = localStorage.getItem('shapesMangaAppUserId'); if (!userId) { userId = crypto.randomUUID(); localStorage.setItem('shapesMangaAppUserId', userId); } this.config.userId = userId; },
            setupEventListeners() { /* ... same ... */
                document.getElementById('saveApiSettingsBtn')?.addEventListener('click', () => this.saveApiSettings());
                document.getElementById('saveDisplaySettingsBtn')?.addEventListener('click', () => this.saveDisplaySettings());
                document.getElementById('createMangaForm').addEventListener('submit', (e) => { e.preventDefault(); this.handleCreateNewManga(); });
                document.getElementById('mangaLibraryGrid').addEventListener('click', (e) => { const card = e.target.closest('.manga-card'); if (card && card.dataset.mangaId) this.navigateToMangaDetail(card.dataset.mangaId); });
                document.getElementById('continueStoryBtn')?.addEventListener('click', () => { if (this.currentMangaId) this.handleContinueStory(this.currentMangaId); });
                document.getElementById('deleteMangaBtn')?.addEventListener('click', () => { if (this.currentMangaId) this.handleDeleteManga(this.currentMangaId); });
                document.getElementById('exportMangaBtn')?.addEventListener('click', () => { if (this.currentMangaId) this.exportManga(this.currentMangaId); });
                document.getElementById('exportChapterBtn')?.addEventListener('click', () => { if (this.currentMangaId !== null && this.currentChapterIndex !== null) this.exportChapter(this.currentMangaId, this.currentChapterIndex); });
                document.getElementById('importFile')?.addEventListener('change', (e) => this.handleImportFile(e));
                document.getElementById('characterToolForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.handleAddCharacterManually(); });
                document.getElementById('askShapeForCharacterBtn')?.addEventListener('click', () => this.handleAskShapeForCharacter());
                document.getElementById('charToolMangaSelect')?.addEventListener('change', (e) => this.renderExistingCharacters(e.target.value));
                document.getElementById('plotToolForm')?.addEventListener('submit', (e) => { e.preventDefault(); this.handleSavePlotNotes(); });
                document.getElementById('askShapeForPlotBtn')?.addEventListener('click', () => this.handleAskShapeForPlot());
                document.getElementById('plotToolMangaSelect')?.addEventListener('change', (e) => this.loadPlotNotesForManga(e.target.value));
                document.getElementById('themeSelector')?.addEventListener('change', (e) => { this.config.theme = e.target.value; this.applyTheme(); /* Saved by button */ });
                document.getElementById('artStylePresetGlobal')?.addEventListener('change', (e) => { this.config.artStylePresetGlobal = e.target.value; /* Saved by button */ });
                document.getElementById('customArtStylePreset').addEventListener('input', (e) => { this.config.customArtStylePreset = e.target.value; this.populateArtStyleDropdowns(); });
                document.getElementById('saveMangaArtStyleBtn')?.addEventListener('click', () => this.saveMangaSpecificArtStyle());
                
                // Delegated listeners
                document.getElementById('view-manga-detail').addEventListener('click', (e) => { if (e.target.closest('.edit-manga-title-btn')) this.editMangaDetail('title', this.currentMangaId); if (e.target.closest('.edit-manga-desc-btn')) this.editMangaDetail('description', this.currentMangaId); if (e.target.closest('.regen-btn') && e.target.dataset.imageType && this.currentMangaId) { this.handleRegenerateImage(this.currentMangaId, null, e.target.dataset.imageType); } });
                document.getElementById('view-chapter').addEventListener('click', (e) => { if (e.target.closest('#editChapterTitleBtn')) { if (this.currentMangaId && this.currentChapterIndex !== null) this.editChapterTitle(this.currentMangaId, this.currentChapterIndex); } else if (e.target.closest('.regen-btn') && e.target.dataset.imageType === 'lastPanel' && this.currentMangaId && this.currentChapterIndex !== null) { this.handleRegenerateImage(this.currentMangaId, this.currentChapterIndex, 'lastPanel'); } });
            },
            _toCamelCase(str) { return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase()); },
            router() { /* ... (same) ... */ const hash = window.location.hash || '#library'; this.updateActiveNav(hash); Object.values(this.views).forEach(view => view.classList.remove('active')); let viewKey = hash.substring(1); let camelCaseViewKey = this._toCamelCase(viewKey); if (hash.startsWith('#manga-detail/')) { const mangaId = hash.split('/')[1]; this.currentMangaId = mangaId; this.renderMangaDetail(mangaId); this.views.mangaDetail.classList.add('active'); } else if (hash.startsWith('#chapter/')) { const parts = hash.split('/'); this.currentMangaId = parts[1]; this.currentChapterIndex = parseInt(parts[2], 10); this.renderChapterView(this.currentMangaId, this.currentChapterIndex); this.views.chapter.classList.add('active'); } else if (this.views[camelCaseViewKey]) { if (camelCaseViewKey === 'settings') this.renderSettings(); if (camelCaseViewKey === 'library') this.renderLibrary(); if (camelCaseViewKey === 'characterTool' || camelCaseViewKey === 'plotTool') { this.populateMangaSelectsForTools(); if (camelCaseViewKey === 'characterTool') this.renderExistingCharacters(document.getElementById('charToolMangaSelect').value); if (camelCaseViewKey === 'plotTool') this.loadPlotNotesForManga(document.getElementById('plotToolMangaSelect').value); } this.views[camelCaseViewKey].classList.add('active'); } else { this.renderLibrary(); this.views.library.classList.add('active'); } },
            updateActiveNav(hash) { /* ... (same, make sure keys match) ... */ Object.values(this.navLinks).forEach(link => link?.classList.remove('active')); let activeSet = false; if (hash.startsWith('#manga-detail/') || hash.startsWith('#chapter/')) { if (this.navLinks.library) this.navLinks.library.classList.add('active'); activeSet = true; } else { const navKey = this._toCamelCase(hash.substring(1)); if (this.navLinks[navKey]) { this.navLinks[navKey].classList.add('active'); activeSet = true; } } if (!activeSet && this.navLinks.library) this.navLinks.library.classList.add('active'); },
            navigateToMangaDetail(mangaId) { window.location.hash = `#manga-detail/${mangaId}`; },
            navigateToChapter(mangaId, chapterIndex) { window.location.hash = `#chapter/${mangaId}/${chapterIndex}`; },
            loadConfig() { /* ... same ... */ this.config.apiKey = localStorage.getItem('shapesApiKey') || ''; this.config.shapeVanityUrl = localStorage.getItem('shapesShapeVanityUrl') || ''; this.config.shapeDisplayName = localStorage.getItem('shapesShapeDisplayName') || ''; this.config.theme = localStorage.getItem('shapesMangaTheme') || 'default'; this.config.artStylePresetGlobal = localStorage.getItem('shapesMangaArtStyleGlobal') || ''; this.config.customArtStylePreset = localStorage.getItem('shapesMangaCustomArtStyle') || ''; if (this.config.shapeVanityUrl) { const username = this.config.shapeVanityUrl.split('/').pop(); this.config.shapeUsername = username; if (!this.config.shapeDisplayName) { this.fetchShapeProfile(username); } } this.updateShapeInfoDisplay(); },
            saveApiSettings() { /* ... same ... */ this.config.apiKey = document.getElementById('apiKey').value; const newVanityUrl = document.getElementById('shapeVanityUrl').value; localStorage.setItem('shapesApiKey', this.config.apiKey); localStorage.setItem('shapesShapeVanityUrl', newVanityUrl); if (newVanityUrl && newVanityUrl !== this.config.shapeVanityUrl) { this.config.shapeVanityUrl = newVanityUrl; const username = newVanityUrl.split('/').pop(); this.config.shapeUsername = username; this.fetchShapeProfile(username); } else if (!newVanityUrl) { this.config.shapeVanityUrl = ''; this.config.shapeUsername = ''; this.config.shapeDisplayName = ''; localStorage.removeItem('shapesShapeDisplayName'); } this.updateShapeInfoDisplay(); this.showStatusMessage('settingsStatus', 'API Settings saved!', 'success'); },
            saveDisplaySettings() { /* ... same ... */ this.config.theme = document.getElementById('themeSelector').value; this.config.artStylePresetGlobal = document.getElementById('artStylePresetGlobal').value; this.config.customArtStylePreset = document.getElementById('customArtStylePreset').value.trim(); localStorage.setItem('shapesMangaTheme', this.config.theme); localStorage.setItem('shapesMangaArtStyleGlobal', this.config.artStylePresetGlobal); localStorage.setItem('shapesMangaCustomArtStyle', this.config.customArtStylePreset); this.applyTheme(); this.populateArtStyleDropdowns(); this.showStatusMessage('displaySettingsStatus', 'Display Settings saved!', 'success'); },
            saveMangaSpecificArtStyle() { /* ... same ... */ if (!this.currentMangaId) return; const manga = this.getMangaById(this.currentMangaId); if (!manga) return; const selectEl = document.getElementById('mangaSpecificArtStylePreset'); manga.artStylePreset = selectEl.value; this.saveMangas(); this.showStatusMessage('mangaDetailStatus', `Art style for "${manga.title}" saved!`, 'success'); },
            async fetchShapeProfile(shapeUsername) { /* ... same ... */ if (!shapeUsername) { this.config.shapeDisplayName = ''; localStorage.removeItem('shapesShapeDisplayName'); this.updateShapeInfoDisplay(); return; } this.showStatusMessage('settingsStatus', `Fetching profile for ${shapeUsername}...`, 'info'); try { const response = await fetch(`https://api.shapes.inc/shapes/public/${shapeUsername}`); if (!response.ok) { throw new Error(`Failed to fetch profile (${response.status})`); } const profileData = await response.json(); this.config.shapeDisplayName = profileData.displayName || profileData.username || shapeUsername; localStorage.setItem('shapesShapeDisplayName', this.config.shapeDisplayName); this.showStatusMessage('settingsStatus', `Using Shape: ${this.config.shapeDisplayName}`, 'success', false, true); } catch (error) { console.error("Error fetching shape profile:", error); this.showStatusMessage('settingsStatus', `Could not fetch profile: ${error.message}`, 'error'); this.config.shapeDisplayName = `[${shapeUsername}] (Profile Error)`; } this.updateShapeInfoDisplay(); },
            updateShapeInfoDisplay() { /* ... same ... */ const infoEl = document.getElementById('shapeInfo'); if (infoEl) { if (this.config.shapeDisplayName && this.config.shapeDisplayName.includes('(Profile Error)')) { infoEl.textContent = `Error with Shape: ${this.config.shapeDisplayName}`; infoEl.style.color = 'var(--danger-color)'; } else if (this.config.shapeDisplayName) { infoEl.textContent = `Current Shape: ${this.config.shapeDisplayName}`; infoEl.style.color = 'var(--text-color)'; } else if (this.config.shapeVanityUrl) { infoEl.textContent = `Using Shape at: ${this.config.shapeVanityUrl} (Fetching profile...).`; infoEl.style.color = 'var(--text-color)'; } else { infoEl.textContent = 'No Shape configured.'; infoEl.style.color = 'var(--text-color)'; } } },
            renderSettings() { /* ... same ... */ document.getElementById('apiKey').value = this.config.apiKey; document.getElementById('shapeVanityUrl').value = this.config.shapeVanityUrl; document.getElementById('themeSelector').value = this.config.theme; document.getElementById('artStylePresetGlobal').value = this.config.artStylePresetGlobal; document.getElementById('customArtStylePreset').value = this.config.customArtStylePreset; this.updateShapeInfoDisplay(); },
            loadMangas() { /* ... same ... */ const storedMangas = localStorage.getItem('shapesMangas'); if (storedMangas) { try {this.data.mangas = JSON.parse(storedMangas); if (!Array.isArray(this.data.mangas)) this.data.mangas = []; this.data.mangas.forEach(m => { if(!m.characters) m.characters = []; if(!m.mainPlot) m.mainPlot = ''; if(!m.plotTwists) m.plotTwists = ''; if(!m.artStylePreset) m.artStylePreset = '';});} catch(e) {this.data.mangas = []; console.error("Error parsing mangas from localStorage", e); localStorage.removeItem('shapesMangas');} } else {this.data.mangas = [];} },
            saveMangas() { localStorage.setItem('shapesMangas', JSON.stringify(this.data.mangas)); },
            getMangaById(id) { return this.data.mangas.find(m => m.id === id); },
            _renderImageIntoContainer(container, imageUrl, altText, placeholderTextContent, regenCallback = null, imageType = null) { /* ... same ... */ container.innerHTML = ''; const regenBtnHtml = regenCallback ? `<button class="regen-btn" data-image-type="${imageType}" title="Regenerate Image"><svg class="icon" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg></button>` : ''; if (imageUrl && imageUrl.startsWith('http')) { const img = document.createElement('img'); img.src = imageUrl; img.alt = altText; img.onerror = () => { container.innerHTML = `<span class="placeholder-text">${placeholderTextContent} (Failed to load)</span>${regenBtnHtml}`; }; container.appendChild(img); if(regenCallback && container.querySelector('.regen-btn') == null) container.insertAdjacentHTML('beforeend', regenBtnHtml); } else { container.innerHTML = `<span class="placeholder-text">${placeholderTextContent}</span>${regenBtnHtml}`; } },
            renderLibrary() { /* ... same ... */ const grid = document.getElementById('mangaLibraryGrid'); const noMangaMsg = document.getElementById('noMangaMessage'); grid.innerHTML = ''; if (this.data.mangas.length === 0) { noMangaMsg.style.display = 'block'; return; } noMangaMsg.style.display = 'none'; this.data.mangas.forEach(manga => { const card = document.createElement('div'); card.className = 'manga-card'; card.dataset.mangaId = manga.id; const coverImageContainer = document.createElement('div'); coverImageContainer.className = 'cover-image image-container'; this._renderImageIntoContainer(coverImageContainer, manga.coverImageUrl, `${manga.title || 'Untitled'} Cover`, `${manga.title || 'Untitled'}<br>(No Cover)`); const titleOverlay = document.createElement('div'); titleOverlay.className = 'title-on-cover'; titleOverlay.textContent = manga.title || 'Untitled'; coverImageContainer.appendChild(titleOverlay); card.appendChild(coverImageContainer); grid.appendChild(card); }); },
            renderMangaDetail(mangaId) { /* ... same ... */ const manga = this.getMangaById(mangaId); const contentDiv = document.getElementById('mangaDetailContent'); const continueBtn = document.getElementById('continueStoryBtn'); const deleteBtn = document.getElementById('deleteMangaBtn'); const exportMangaBtn = document.getElementById('exportMangaBtn'); const mangaArtStyleSelect = document.getElementById('mangaSpecificArtStylePreset'); this.showStatusMessage('mangaDetailStatus', '', 'info', false, true); if (!manga) { contentDiv.innerHTML = '<p>Manga not found.</p>'; if(continueBtn) continueBtn.style.display = 'none'; if(deleteBtn) deleteBtn.style.display = 'none'; if(exportMangaBtn) exportMangaBtn.style.display = 'none'; if(mangaArtStyleSelect) mangaArtStyleSelect.parentElement.style.display = 'none'; return; } let chaptersHtml = '<h3>Chapters</h3><ul class="chapters-list">'; if (manga.chapters && manga.chapters.length > 0) { manga.chapters.forEach((chapter, index) => { chaptersHtml += `<li><a href="#chapter/${manga.id}/${index}">${chapter.title || `Chapter ${index + 1}`}</a></li>`; }); } else { chaptersHtml += '<li>No chapters yet.</li>'; } chaptersHtml += '</ul>'; contentDiv.innerHTML = ` <div class="manga-detail-header"> <div class="banner-image image-container" id="detailBannerImgContainer"></div> <div class="manga-icon image-container" id="detailIconImgContainer"></div> <h2 id="mangaTitleH2">${manga.title || 'Untitled'} <button class="edit-btn edit-manga-title-btn" title="Edit Title"> <svg class="icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"> <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14.304 4.844 2.852 2.852M7 7H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-4.5m2.409-9.91a2.017 2.017 0 0 1 0 2.853l-6.844 6.844L8 14l.713-3.565 6.844-6.844a2.015 2.015 0 0 1 2.852 0Z"/> </svg> </button></h2> <p class="author">By: ${manga.authorName || 'Unknown'}</p> <div class="description-container" id="mangaDescContainer">${manga.description || '...'} <button class="edit-btn edit-manga-desc-btn" title="Edit Description"> <svg class="icon" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"> <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14.304 4.844 2.852 2.852M7 7H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-4.5m2.409-9.91a2.017 2.017 0 0 1 0 2.853l-6.844 6.844L8 14l.713-3.565 6.844-6.844a2.015 2.015 0 0 1 2.852 0Z"/> </svg> </button></div> </div> ${chaptersHtml} `; this._renderImageIntoContainer(document.getElementById('detailBannerImgContainer'), manga.bannerImageUrl, `${manga.title} Banner`, '(No Banner)', this.handleRegenerateImage.bind(this), 'banner'); this._renderImageIntoContainer(document.getElementById('detailIconImgContainer'), manga.iconImageUrl, `${manga.title} Icon`, '(No Icon)', this.handleRegenerateImage.bind(this), 'icon'); if(mangaArtStyleSelect) { mangaArtStyleSelect.value = manga.artStylePreset || ""; mangaArtStyleSelect.parentElement.style.display = 'block';} if(continueBtn) continueBtn.style.display = (manga.status !== 'completed') ? 'inline-block' : 'none'; if(deleteBtn) deleteBtn.style.display = 'inline-block'; if(exportMangaBtn) exportMangaBtn.style.display = 'inline-block'; document.getElementById('backToMangaDetail')?.setAttribute('href', `#manga-detail/${mangaId}`); },
            renderChapterView(mangaId, chapterIndex) { /* ... same ... */ const manga = this.getMangaById(mangaId); const exportChapterBtn = document.getElementById('exportChapterBtn'); const chapterTitleTextEl = document.getElementById('chapterTitleText'); const editChapterTitleBtnEl = document.getElementById('editChapterTitleBtn'); if (!manga || !manga.chapters || !manga.chapters[chapterIndex]) { if (chapterTitleTextEl) chapterTitleTextEl.textContent = 'Chapter Not Found'; document.getElementById('chapterContent').innerHTML = '<p>Could not load content.</p>'; if(exportChapterBtn) exportChapterBtn.style.display = 'none'; if(editChapterTitleBtnEl) editChapterTitleBtnEl.style.display = 'none'; return; } const chapter = manga.chapters[chapterIndex]; if(chapterTitleTextEl) chapterTitleTextEl.textContent = chapter.title || `Chapter ${chapterIndex + 1}`; if(editChapterTitleBtnEl) editChapterTitleBtnEl.style.display = 'inline-block'; let panelsHtml = ''; chapter.panels.forEach(panel => { if (panel.type === 'text') panelsHtml += `<div class="panel-description"><p>${panel.content.replace(/\n/g, '</p><p>')}</p></div>`; }); const chapterContentEl = document.getElementById('chapterContent'); chapterContentEl.innerHTML = panelsHtml; if (chapter.lastPanelImageUrl || chapter.finalPanelDescription) { const lastPanelContainer = document.createElement('div'); lastPanelContainer.className = 'last-panel-image-container'; let lastPanelTextContent = `<h3>End of Chapter</h3>`; if (chapter.finalPanelDescription) lastPanelTextContent += `<p><em>${chapter.finalPanelDescription}</em></p>`; lastPanelContainer.innerHTML = lastPanelTextContent; const imageDiv = document.createElement('div'); imageDiv.className = 'image-container'; imageDiv.style.minHeight = '150px'; this._renderImageIntoContainer(imageDiv, chapter.lastPanelImageUrl, "Last panel art", "(No final image)", this.handleRegenerateImage.bind(this), 'lastPanel'); lastPanelContainer.appendChild(imageDiv); chapterContentEl.appendChild(lastPanelContainer); } else { chapterContentEl.innerHTML += `<div class="panel-description"><p><em>(Chapter end.)</em></p></div>`; } if(exportChapterBtn) exportChapterBtn.style.display = 'inline-block'; document.getElementById('backToMangaDetail').setAttribute('href', `#manga-detail/${mangaId}`); },
            _extractImageUrlFromContent(content) { /* ... (same) ... */ const urlMatch = content.match(/https?:\/\/\S+\.(png|jpg|jpeg|gif|webp)/i); if (urlMatch) return urlMatch[0]; return this.parseValue(content, "IMAGE_URL"); },
            async callShapesAPI(messages, mangaIdForChannel = null, isWackCall = false, specificPurpose = "") { /* ... (same) ... */ const useSimulation = !this.config.apiKey || !this.config.shapeVanityUrl; let statusElemId = 'creationStatus'; if (window.location.hash.includes('#manga-detail') || window.location.hash.includes('#chapter')) statusElemId = 'mangaDetailStatus'; if (isWackCall) statusElemId = 'mangaDetailStatus'; if (specificPurpose.includes("tool_")) { let toolName = specificPurpose.replace("tool_", "").replace("_ask", ""); statusElemId = toolName + "ToolOutput"; } if (useSimulation && !isWackCall) { this.showStatusMessage(statusElemId, 'API Key/URL not set. Using SIMULATED response for ' + specificPurpose, 'error'); return new Promise((resolve) => { setTimeout(() => { console.warn("SIMULATING API CALL for purpose:", specificPurpose); let simResponse = {}; if (specificPurpose === "manga_setup_text") { simResponse = { choices: [{ message: { content: `MANGA_TITLE: Sim Scroll\nSHORT_DESCRIPTION: Sim desc.` }}]}; } else if (specificPurpose.startsWith("image_")) { const imageType = specificPurpose.split('_')[1]; simResponse = { choices: [{ message: { content: `!imagine. Img: https://picsum.photos/seed/sim${imageType}${Date.now()}/${imageType === 'banner' ? '800/200' : (imageType === 'icon' ? '100/100' : '400/600')}` }}]}; } else if (specificPurpose === "chapter_text") { simResponse = { choices: [{ message: { content: `CHAPTER_TITLE: Sim Ink\nCHAPTER_CONTENT: Sim shop...\n[END_OF_CHAPTER]\nFINAL_PANEL_DESCRIPTION: Sim eyes...` }}]}; } else if (specificPurpose === "tool_character_ask") { simResponse = { choices: [{ message: { content: `Character Ideas:\n1. Sim Kaito: Spiky hair...\n2. Sim Elara: Wise guide...`}}]}} else if (specificPurpose === "tool_plot_ask") { simResponse = { choices: [{ message: { content: `Plot Ideas:\n- Sim villain revealed.\n- Sim artifact cursed...`}}]}} else { simResponse = { choices: [{ message: { content: "Generic sim response." } }] }; } resolve(simResponse); }, 700); }); } else if (useSimulation && isWackCall) { this.showStatusMessage(statusElemId, 'API Key/URL not set. Cannot send !wack.', 'error'); return Promise.resolve({ choices: [{ message: { content: "Simulated: !wack not sent." } }] }); } const headers = { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json', 'X-User-Id': this.config.userId }; if (mangaIdForChannel) headers['X-Channel-Id'] = mangaIdForChannel; const body = JSON.stringify({ model: this.config.shapeVanityUrl, messages: messages }); try { const response = await fetch('https://api.shapes.inc/v1/chat/completions', { method: 'POST', headers: headers, body: body }); if (!response.ok) { const errorData = await response.json().catch(() => ({ error: { message: 'Unknown API error' } })); throw new Error(`API Error ${response.status}: ${errorData.error?.message || response.statusText}`); } const responseData = await response.json(); if(isWackCall && responseData.choices && responseData.choices[0] && responseData.choices[0].message) { console.log("Shape response to !wack:", responseData.choices[0].message.content); } return responseData; } catch (error) { console.error("Shapes API call failed:", error); this.showStatusMessage(statusElemId, `API Call Error: ${error.message}`, 'error'); throw error; } },
            editMangaDetail(field, mangaId) { /* ... (same) ... */ const manga = this.getMangaById(mangaId); if (!manga) return; const currentValue = manga[field]; const newValue = prompt(`Edit Manga ${field === 'title' ? 'Title' : 'Description'}:`, currentValue); if (newValue !== null && newValue !== currentValue) { manga[field] = newValue; this.saveMangas(); this.renderMangaDetail(mangaId); this.showStatusMessage('mangaDetailStatus', `${field === 'title' ? 'Title' : 'Description'} updated!`, 'success'); } },
            editChapterTitle(mangaId, chapterIndex) { /* ... (same) ... */ const manga = this.getMangaById(mangaId); if (!manga || !manga.chapters[chapterIndex]) return; const chapter = manga.chapters[chapterIndex]; const currentValue = chapter.title || `Chapter ${chapterIndex + 1}`; const newTitle = prompt("Edit Chapter Title:", currentValue); if (newTitle !== null && newTitle !== currentValue) { chapter.title = newTitle; this.saveMangas(); this.renderChapterView(mangaId, chapterIndex); } },
            async handleRegenerateImage(mangaId, chapterIndex, imageType) { /* ... (same) ... */ const manga = this.getMangaById(mangaId); if (!manga) return; this.showStatusMessage('mangaDetailStatus', `Regenerating ${imageType} image...`, 'info', false, false); let imagePromptText = ""; let currentImageUrlProperty = ""; const selectedArtStyle = manga.artStylePreset || this.config.artStylePresetGlobal || "in a hand-drawn manga art style, black and white ink drawing"; switch(imageType) { case 'cover': imagePromptText = `!imagine a compelling manga cover for "${manga.title}" premise: "${manga.description}", ${selectedArtStyle}`; currentImageUrlProperty = 'coverImageUrl'; break; case 'banner': imagePromptText = `!imagine a wide banner for manga "${manga.title}", ${selectedArtStyle}`; currentImageUrlProperty = 'bannerImageUrl'; break; case 'icon': imagePromptText = `!imagine a small square icon for manga "${manga.title}", ${selectedArtStyle}`; currentImageUrlProperty = 'iconImageUrl'; break; case 'lastPanel': if (chapterIndex === null || !manga.chapters[chapterIndex] || !manga.chapters[chapterIndex].finalPanelDescription) { this.showStatusMessage('mangaDetailStatus', 'Missing final panel description.', 'error'); return; } const chapter = manga.chapters[chapterIndex]; imagePromptText = `!imagine ${chapter.finalPanelDescription}, for manga "${manga.title}", ${selectedArtStyle}`; currentImageUrlProperty = 'lastPanelImageUrl'; break; default: this.showStatusMessage('mangaDetailStatus', 'Unknown image type for regen.', 'error'); return; } try { const response = await this.callShapesAPI([{ role: 'user', content: imagePromptText }], manga.id, false, `image_${imageType}_regen`); const newImageUrl = this._extractImageUrlFromContent(response.choices[0].message.content); if (newImageUrl) { if (imageType === 'lastPanel') { manga.chapters[chapterIndex][currentImageUrlProperty] = newImageUrl; } else { manga[currentImageUrlProperty] = newImageUrl; } this.saveMangas(); if (imageType === 'lastPanel') this.renderChapterView(mangaId, chapterIndex); else this.renderMangaDetail(mangaId); this.showStatusMessage('mangaDetailStatus', `${imageType} image regenerated!`, 'success'); } else { this.showStatusMessage('mangaDetailStatus', `Failed to get new URL for ${imageType}. Shape says: ${response.choices[0].message.content.substring(0,100)}...`, 'error'); } } catch (error) { this.showStatusMessage('mangaDetailStatus', `Error regenerating ${imageType}: ${error.message}`, 'error'); } },
            async handleCreateNewManga() { /* ... (same) ... */ const idea = document.getElementById('mangaIdea').value; if (!idea) { this.showStatusMessage('creationStatus', 'Please enter manga idea.', 'error'); return; } if (!this.config.shapeDisplayName && this.config.shapeVanityUrl && !this.config.shapeVanityUrl.includes('picsum.photos')) { await this.fetchShapeProfile(this.config.shapeUsername); } document.getElementById('creationLoading').style.display = 'block'; document.getElementById('startMangaCreationBtn').disabled = true; const newManga = { id: crypto.randomUUID(), authorName: this.config.shapeDisplayName || 'A Shapes Storyteller', chapters: [], characters: [], mainPlot: '', plotTwists: '', artStylePreset: '', status: 'ongoing' }; const artStyleSuffix = this.config.artStylePresetGlobal || "in a hand-drawn manga art style, black and white ink drawing"; try { this.showStatusMessage('creationStatus', 'Conceptualizing (1/4 Text)...', 'info', false, false); let prompt = `User's manga idea: "${idea}". Provide: MANGA_TITLE: [Title] SHORT_DESCRIPTION: [Summary]`; let response = await this.callShapesAPI([{ role: 'user', content: prompt }], null, false, "manga_setup_text"); let content = response.choices[0].message.content; newManga.title = this.parseValue(content, "MANGA_TITLE") || `Untitled ${Date.now()}`; newManga.description = this.parseValue(content, "SHORT_DESCRIPTION"); this.showStatusMessage('creationStatus', `Title: ${newManga.title}. Cover (2/4 Img)...`, 'info', true, false); prompt = `!imagine a compelling manga cover for a series titled "${newManga.title}" with premise: "${newManga.description}", ${artStyleSuffix}`; response = await this.callShapesAPI([{ role: 'user', content: prompt }], newManga.id, false, "image_cover"); newManga.coverImageUrl = this._extractImageUrlFromContent(response.choices[0].message.content); this.showStatusMessage('creationStatus', `Banner (3/4 Img)...`, 'info', true, false); prompt = `!imagine a wide banner image for manga series "${newManga.title}", ${artStyleSuffix}`; response = await this.callShapesAPI([{ role: 'user', content: prompt }], newManga.id, false, "image_banner"); newManga.bannerImageUrl = this._extractImageUrlFromContent(response.choices[0].message.content); this.showStatusMessage('creationStatus', `Icon (4/4 Img)...`, 'info', true, false); prompt = `!imagine a small square icon for manga series "${newManga.title}", ${artStyleSuffix}`; response = await this.callShapesAPI([{ role: 'user', content: prompt }], newManga.id, false, "image_icon"); newManga.iconImageUrl = this._extractImageUrlFromContent(response.choices[0].message.content); this.data.mangas.push(newManga); this.saveMangas(); this.showStatusMessage('creationStatus', `Manga "${newManga.title}" created!`, 'success'); document.getElementById('mangaIdea').value = ''; this.navigateToMangaDetail(newManga.id); } catch (error) { this.showStatusMessage('creationStatus', `Creation error: ${error.message}`, 'error'); } finally { document.getElementById('creationLoading').style.display = 'none'; document.getElementById('startMangaCreationBtn').disabled = false; } },
            async handleContinueStory(mangaId) { /* ... (same) ... */ const manga = this.getMangaById(mangaId); if (!manga) return; document.getElementById('chapterCreationLoading').style.display = 'block'; const continueBtn = document.getElementById('continueStoryBtn'); if(continueBtn) continueBtn.disabled = true; this.showStatusMessage('mangaDetailStatus', 'Chapter text (1/2)...', 'info', false, false); const nextChapterNumber = manga.chapters.length + 1; let previousChaptersSummary = manga.chapters.map((ch, i) => `Ch ${i+1} ("${ch.title || ''}"): ${this.summarizeChapter(ch)}`).join('\n'); if (previousChaptersSummary.length > 700) { previousChaptersSummary = "Recent events:\n" + manga.chapters.slice(-2).map((ch, i) => `Ch ${manga.chapters.length-1+i} ("${ch.title||''}"): ${this.summarizeChapter(ch)}`).join('\n'); } let contextForShape = `Continue manga "${manga.title}" (ID: ${manga.id}). Author: ${manga.authorName}.\nPremise: "${manga.description}".\n`; if (manga.mainPlot) contextForShape += `Main Plot Goal: ${manga.mainPlot}\n`; if (manga.plotTwists) contextForShape += `Consider these Upcoming Plot Twists/Events: ${manga.plotTwists}\n`; if (manga.characters && manga.characters.length > 0) { contextForShape += "Key Characters to maintain consistency for:\n"; manga.characters.forEach(char => { contextForShape += `- Name: ${char.name}. Appearance: ${char.appearance}. Personality: ${char.personality}\n`; }); } contextForShape += `${previousChaptersSummary ? `\nPrevious Chapters Summary:\n${previousChaptersSummary}\n` : ''}Write Ch ${nextChapterNumber}. Provide: CHAPTER_TITLE: [Title] CHAPTER_CONTENT: [Narrative] [END_OF_CHAPTER] FINAL_PANEL_DESCRIPTION: [Image desc.] If story complete: [STORY_COMPLETE]`; const artStyleSuffix = manga.artStylePreset || this.config.artStylePresetGlobal || `, in a consistent hand-drawn manga art style for series "${manga.title}", black and white ink drawing`; let chapterData = {}; try { let response = await this.callShapesAPI([{role: 'user', content: contextForShape}], manga.id, false, "chapter_text"); let content = response.choices[0].message.content; chapterData = this.parseChapterContent(content); this.showStatusMessage('mangaDetailStatus', `Text done. Final image (2/2)...`, 'info', true, false); if (chapterData.finalPanelDescription) { let imagePrompt = `!imagine ${chapterData.finalPanelDescription}${artStyleSuffix}`; response = await this.callShapesAPI([{ role: 'user', content: imagePrompt }], manga.id, false, "image_last_panel"); chapterData.lastPanelImageUrl = this._extractImageUrlFromContent(response.choices[0].message.content); } manga.chapters.push(chapterData); if (content.includes("[STORY_COMPLETE]")) { manga.status = 'completed'; if(continueBtn) continueBtn.style.display = 'none'; this.showStatusMessage('mangaDetailStatus', 'Story Complete!', 'success', true, false); } else { this.showStatusMessage('mangaDetailStatus', `Chapter "${chapterData.title||nextChapterNumber}" created!`, 'success', true, false); } this.saveMangas(); this.renderMangaDetail(manga.id); this.navigateToChapter(manga.id, manga.chapters.length - 1); } catch (error) { this.showStatusMessage('mangaDetailStatus', `Chapter error: ${error.message}`, 'error', true, false); } finally { document.getElementById('chapterCreationLoading').style.display = 'none'; if(continueBtn) continueBtn.disabled = false; } },
            async handleDeleteManga(mangaId) { /* ... same ... */ const manga = this.getMangaById(mangaId); if (!manga) return; if (confirm(`Delete "${manga.title || 'this manga'}"?`)) { this.showStatusMessage('mangaDetailStatus', `Deleting "${manga.title}" & wacking memory...`, 'info', false, false); try { if (this.config.apiKey && this.config.shapeVanityUrl) { await this.callShapesAPI( [{ role: 'user', content: '!wack' }], manga.id, true ); this.showStatusMessage('mangaDetailStatus', `STM for "${manga.title}" wacked.`, 'info', true, false); } else { this.showStatusMessage('mangaDetailStatus', `API not configured. No !wack. Deleted locally.`, 'error', true, false); } } catch (error) { this.showStatusMessage('mangaDetailStatus', `!wack error: ${error.message}. Deleted locally.`, 'error', true, false); } this.data.mangas = this.data.mangas.filter(m => m.id !== mangaId); this.saveMangas(); this.showStatusMessage('mangaDetailStatus', `"${manga.title}" deleted.`, 'success', true, false); const continueBtn = document.getElementById('continueStoryBtn'); const deleteBtn = document.getElementById('deleteMangaBtn'); if(continueBtn) continueBtn.style.display = 'none'; if(deleteBtn) deleteBtn.style.display = 'none'; setTimeout(() => { window.location.hash = '#library'; }, 2500); } },
            _downloadJSON(data, filename) { /* ... same ... */ const jsonStr = JSON.stringify(data, null, 2); const blob = new Blob([jsonStr], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); },
            exportManga(mangaId) { /* ... same ... */ const manga = this.getMangaById(mangaId); if (!manga) { this.showStatusMessage('mangaDetailStatus', 'Error: Manga not found for export.', 'error'); return; } const filename = `${(manga.title || 'untitled-manga').replace(/\s+/g, '-')}_full.json`; this._downloadJSON(manga, filename); this.showStatusMessage('mangaDetailStatus', `"${manga.title}" exported!`, 'success'); },
            exportChapter(mangaId, chapterIndex) { /* ... same ... */ const manga = this.getMangaById(mangaId); if (!manga || !manga.chapters || !manga.chapters[chapterIndex]) { this.showStatusMessage('mangaDetailStatus', 'Error: Chapter not found for export.', 'error'); return; } const chapter = manga.chapters[chapterIndex]; const filename = `${(manga.title || 'untitled-manga').replace(/\s+/g, '-')}_chapter-${chapterIndex + 1}.json`; this._downloadJSON(chapter, filename); alert(`Chapter "${chapter.title || chapterIndex + 1}" exported! Check your downloads.`); },
            handleImportFile(event) { /* ... same ... */ const file = event.target.files[0]; if (!file) { this.showStatusMessage('importStatus', 'No file selected.', 'error'); return; } if (file.type !== "application/json") { this.showStatusMessage('importStatus', 'Invalid file type. Please select a .json file.', 'error'); return; } const reader = new FileReader(); reader.onload = (e) => { try { const importedData = JSON.parse(e.target.result); if (importedData.title && Array.isArray(importedData.chapters)) { if (this.data.mangas.find(m => m.id === importedData.id)) { importedData.id = crypto.randomUUID(); this.showStatusMessage('importStatus', 'Imported manga ID conflicted, assigned new ID.', 'info'); } if(!importedData.characters) importedData.characters = []; if(!importedData.mainPlot) importedData.mainPlot = ''; if(!importedData.plotTwists) importedData.plotTwists = ''; if(!importedData.artStylePreset) importedData.artStylePreset = ''; this.data.mangas.push(importedData); this.saveMangas(); this.renderLibrary(); this.showStatusMessage('importStatus', `Novel "${importedData.title}" imported successfully!`, 'success'); } else if (importedData.panels && Array.isArray(importedData.panels)) { const newMangaForChapter = { id: crypto.randomUUID(), title: importedData.title ? `Imported: ${importedData.title}` : `Imported Chapter ${Date.now()}`, description: "Manga created from imported chapter.", authorName: "Imported", coverImageUrl: '', bannerImageUrl: '', iconImageUrl: '', chapters: [importedData], characters:[], mainPlot:'', plotTwists:'', artStylePreset:'', status: 'ongoing' }; this.data.mangas.push(newMangaForChapter); this.saveMangas(); this.renderLibrary(); this.showStatusMessage('importStatus', `Chapter imported as new novel: "${newMangaForChapter.title}"!`, 'success'); } else { throw new Error("Invalid JSON structure for manga or chapter."); } } catch (err) { console.error("Import error:", err); this.showStatusMessage('importStatus', `Import failed: ${err.message}`, 'error'); } finally { event.target.value = null; } }; reader.readAsText(file); },
            populateMangaSelectsForTools() { /* ... same ... */ const charSelect = document.getElementById('charToolMangaSelect'); const plotSelect = document.getElementById('plotToolMangaSelect'); [charSelect, plotSelect].forEach(select => { if (!select) return; const currentVal = select.value; select.innerHTML = '<option value="">-- Select a Manga --</option>'; this.data.mangas.forEach(manga => { const option = document.createElement('option'); option.value = manga.id; option.textContent = manga.title || 'Untitled Manga'; select.appendChild(option); }); if (this.data.mangas.find(m => m.id === currentVal)) { select.value = currentVal; } else if (this.data.mangas.length > 0) { select.value = this.data.mangas[0].id;} if (select.value) { select.dispatchEvent(new Event('change')); } else { if (select === charSelect) this.renderExistingCharacters(null); if (select === plotSelect) this.loadPlotNotesForManga(null); } }); },
            renderExistingCharacters(mangaId) { /* ... same ... */ const listEl = document.getElementById('existingCharactersList'); listEl.innerHTML = ''; if (!mangaId) { listEl.textContent = 'Select a manga to see its characters.'; return; } const manga = this.getMangaById(mangaId); if (!manga || !manga.characters || manga.characters.length === 0) { listEl.textContent = 'No characters defined for this manga yet.'; return; } manga.characters.forEach(char => { const charDiv = document.createElement('div'); charDiv.className = 'character-entry'; charDiv.innerHTML = `<h4>${char.name}</h4><p><strong>Appearance:</strong> ${char.appearance || 'N/A'}</p><p><strong>Personality:</strong> ${char.personality || 'N/A'}</p>`; listEl.appendChild(charDiv); }); },
            handleAddCharacterManually() { /* ... same ... */ const mangaId = document.getElementById('charToolMangaSelect').value; if (!mangaId) { alert("Please select a manga first."); return; } const manga = this.getMangaById(mangaId); if (!manga) { alert("Selected manga not found."); return; } const name = document.getElementById('charToolName').value.trim(); const appearance = document.getElementById('charToolAppearance').value.trim(); const personality = document.getElementById('charToolPersonality').value.trim(); if (!name) { alert("Character name is required."); return; } if (!manga.characters) manga.characters = []; manga.characters.push({ name, appearance, personality }); this.saveMangas(); this.renderExistingCharacters(mangaId); document.getElementById('characterToolForm').reset(); this.showStatusMessage('charToolOutput', `Character "${name}" added to "${manga.title}"!`, 'success');},
            async handleAskShapeForCharacter() { /* ... same ... */ const mangaId = document.getElementById('charToolMangaSelect').value; const name = document.getElementById('charToolName').value.trim(); const loadingEl = document.getElementById('charToolLoading'); const outputEl = document.getElementById('charToolOutput'); let mangaContext = "a new manga series"; if (mangaId) { const manga = this.getMangaById(mangaId); if (manga) mangaContext = `the manga titled "${manga.title}" with premise: "${manga.description}"`; } else { mangaContext = document.getElementById('characterMangaContext')?.value || mangaContext; } if (!name && !mangaId && !document.getElementById('characterMangaContext')?.value) { outputEl.textContent = "Provide character name or manga context."; outputEl.style.display = 'block'; return; } loadingEl.style.display = 'block'; outputEl.style.display = 'none'; outputEl.textContent = ''; const prompt = `For ${mangaContext}, help define a character. ${name ? `Name is "${name}".` : `Suggest a name.`} Describe: - Appearance: - Personality/Quirks: - Role:`; try { const response = await this.callShapesAPI([{role: 'user', content: prompt}], mangaId, false, "tool_character_ask"); outputEl.textContent = response.choices[0].message.content; } catch (error) { outputEl.textContent = `Error: ${error.message}`; } finally { loadingEl.style.display = 'none'; outputEl.style.display = 'block'; } },
            loadPlotNotesForManga(mangaId) { /* ... same ... */ const mainPlotEl = document.getElementById('plotToolMainPlot'); const twistsEl = document.getElementById('plotToolTwists'); mainPlotEl.value = ''; twistsEl.value = ''; if (!mangaId) return; const manga = this.getMangaById(mangaId); if (manga) { mainPlotEl.value = manga.mainPlot || ''; twistsEl.value = manga.plotTwists || ''; } },
            handleSavePlotNotes() { /* ... same ... */ const mangaId = document.getElementById('plotToolMangaSelect').value; if (!mangaId) { alert("Please select a manga first."); return; } const manga = this.getMangaById(mangaId); if (!manga) { alert("Selected manga not found."); return; } manga.mainPlot = document.getElementById('plotToolMainPlot').value.trim(); manga.plotTwists = document.getElementById('plotToolTwists').value.trim(); this.saveMangas(); this.showStatusMessage('plotToolOutput', `Plot notes for "${manga.title}" saved!`, 'success'); },
            async handleAskShapeForPlot() { /* ... same ... */ const mangaId = document.getElementById('plotToolMangaSelect').value; const loadingEl = document.getElementById('plotToolLoading'); const outputEl = document.getElementById('plotToolOutput'); let mangaContext = "a new manga series."; let currentPlot = ""; if (mangaId) { const manga = this.getMangaById(mangaId); if (manga) { mangaContext = `manga "${manga.title}" (premise: "${manga.description}").`; if(manga.mainPlot) currentPlot += `Current Plot: ${manga.mainPlot}\n`; if(manga.plotTwists) currentPlot += `Existing Twists: ${manga.plotTwists}\n`; } } else { mangaContext = document.getElementById('plotMangaContext')?.value || mangaContext; } loadingEl.style.display = 'block'; outputEl.style.display = 'none'; outputEl.textContent = ''; const prompt = `Considering ${mangaContext} ${currentPlot ? `\n${currentPlot}` : ''} Suggest new plot ideas, story arcs, or turning points.`; try { const response = await this.callShapesAPI([{role: 'user', content: prompt}], mangaId, false, "tool_plot_ask"); outputEl.textContent = response.choices[0].message.content; } catch (error) { outputEl.textContent = `Error: ${error.message}`; } finally { loadingEl.style.display = 'none'; outputEl.style.display = 'block'; } },
            summarizeChapter(chapter) { /* ... same ... */ return chapter.panels.filter(p => p.type === 'text').slice(0, 1).map(p => p.content.substring(0, 100) + (p.content.length > 100 ? "..." : "")).join(' '); },
            parseValue(text, key) { /* ... same ... */ const regex = new RegExp(`^${key}:\\s*(.+)`, "m"); const match = text.match(regex); return match ? match[1].trim() : null; },
            parseChapterContent(rawContent) { /* ... same ... */ const chapter = { title: null, panels: [], lastPanelImageUrl: null, finalPanelDescription: null }; chapter.title = this.parseValue(rawContent, "CHAPTER_TITLE"); let contentWithoutTitle = rawContent.replace(/^CHAPTER_TITLE:\s*.+\n?/m, '').trim().replace(/^CHAPTER_CONTENT:\s*\n?/im, ''); const endOfChapterMarker = "[END_OF_CHAPTER]"; const finalPanelDescMarker = "FINAL_PANEL_DESCRIPTION:"; let mainContent = contentWithoutTitle; let afterEndContent = ""; const endOfChapterIndex = contentWithoutTitle.indexOf(endOfChapterMarker); if (endOfChapterIndex !== -1) { mainContent = contentWithoutTitle.substring(0, endOfChapterIndex).trim(); afterEndContent = contentWithoutTitle.substring(endOfChapterIndex + endOfChapterMarker.length).trim(); const descMatch = afterEndContent.match(new RegExp(`^${finalPanelDescMarker}\\s*(.+)`, "m")); if (descMatch) chapter.finalPanelDescription = descMatch[1].trim(); } const panelBlocks = mainContent.split(/\n\s*\n/).map(block => block.trim()).filter(block => block.length > 0 && !block.startsWith("FINAL_PANEL_DESCRIPTION:")); panelBlocks.forEach(block => { chapter.panels.push({ type: 'text', content: block }); }); return chapter; },
            showStatusMessage(elementId, message, type = 'info', append = false, autoClear = true) { /* ... same ... */ const el = document.getElementById(elementId); if (el) { el.style.display = message ? 'block' : 'none'; if (!append || !el.classList.contains('status-message')) { el.className = 'status-message'; if (type) el.classList.add(type); } if (append) { const p = document.createElement('p'); p.style.margin = '0'; p.style.padding = '0'; p.innerHTML = message.replace(/\n/g, '<br>'); if(el.firstChild && el.firstChild.nodeName === 'P' && el.classList.contains(type)) { el.firstChild.innerHTML += `<br>${message.replace(/\n/g, '<br>')}`; } else { el.innerHTML = ''; el.appendChild(p); el.className = 'status-message'; if (type) el.classList.add(type); } } else { el.textContent = message; } if (autoClear && type !== 'info' && !append && !message.toLowerCase().includes('deleting') && !message.toLowerCase().includes('step')) { setTimeout(() => { if (el.textContent === message || (el.firstChild && el.firstChild.textContent.includes(message)) ) { el.style.display = 'none'; el.innerHTML = ''; } }, 7000); } } }
        };
        document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
